{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport adapters from \"./adapters\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport INTERNAL from \"./internal\";\nimport logger from \"./logger\"; // Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nvar message_types = INTERNAL.message_types,\n    protocols = INTERNAL.protocols;\nvar supportedProtocols = protocols.slice(0, protocols.length - 1);\nvar indexOf = [].indexOf;\n\nvar Connection = /*#__PURE__*/function () {\n  function Connection(consumer) {\n    _classCallCheck(this, Connection);\n\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n\n  _createClass(Connection, [{\n    key: \"send\",\n    value: function send(data) {\n      if (this.isOpen()) {\n        this.webSocket.send(JSON.stringify(data));\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"open\",\n    value: function open() {\n      if (this.isActive()) {\n        logger.log(\"Attempted to open WebSocket, but existing socket is \".concat(this.getState()));\n        return false;\n      } else {\n        logger.log(\"Opening WebSocket, current state is \".concat(this.getState(), \", subprotocols: \").concat(protocols));\n\n        if (this.webSocket) {\n          this.uninstallEventHandlers();\n        }\n\n        this.webSocket = new adapters.WebSocket(this.consumer.url, protocols);\n        this.installEventHandlers();\n        this.monitor.start();\n        return true;\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        allowReconnect: true\n      },\n          allowReconnect = _ref.allowReconnect;\n\n      if (!allowReconnect) {\n        this.monitor.stop();\n      }\n\n      if (this.isActive()) {\n        return this.webSocket.close();\n      }\n    }\n  }, {\n    key: \"reopen\",\n    value: function reopen() {\n      logger.log(\"Reopening WebSocket, current state is \".concat(this.getState()));\n\n      if (this.isActive()) {\n        try {\n          return this.close();\n        } catch (error) {\n          logger.log(\"Failed to reopen WebSocket\", error);\n        } finally {\n          logger.log(\"Reopening WebSocket in \".concat(this.constructor.reopenDelay, \"ms\"));\n          setTimeout(this.open, this.constructor.reopenDelay);\n        }\n      } else {\n        return this.open();\n      }\n    }\n  }, {\n    key: \"getProtocol\",\n    value: function getProtocol() {\n      if (this.webSocket) {\n        return this.webSocket.protocol;\n      }\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this.isState(\"open\");\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.isState(\"open\", \"connecting\");\n    } // Private\n\n  }, {\n    key: \"isProtocolSupported\",\n    value: function isProtocolSupported() {\n      return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n    }\n  }, {\n    key: \"isState\",\n    value: function isState() {\n      for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n        states[_key] = arguments[_key];\n      }\n\n      return indexOf.call(states, this.getState()) >= 0;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      if (this.webSocket) {\n        for (var state in adapters.WebSocket) {\n          if (adapters.WebSocket[state] === this.webSocket.readyState) {\n            return state.toLowerCase();\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"installEventHandlers\",\n    value: function installEventHandlers() {\n      for (var eventName in this.events) {\n        var handler = this.events[eventName].bind(this);\n        this.webSocket[\"on\".concat(eventName)] = handler;\n      }\n    }\n  }, {\n    key: \"uninstallEventHandlers\",\n    value: function uninstallEventHandlers() {\n      for (var eventName in this.events) {\n        this.webSocket[\"on\".concat(eventName)] = function () {};\n      }\n    }\n  }]);\n\n  return Connection;\n}();\n\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message: function message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n\n    var _JSON$parse = JSON.parse(event.data),\n        identifier = _JSON$parse.identifier,\n        message = _JSON$parse.message,\n        reason = _JSON$parse.reason,\n        reconnect = _JSON$parse.reconnect,\n        type = _JSON$parse.type;\n\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n\n      case message_types.disconnect:\n        logger.log(\"Disconnecting. Reason: \".concat(reason));\n        return this.close({\n          allowReconnect: reconnect\n        });\n\n      case message_types.ping:\n        return this.monitor.recordPing();\n\n      case message_types.confirmation:\n        return this.subscriptions.notify(identifier, \"connected\");\n\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open: function open() {\n    logger.log(\"WebSocket onopen event, using '\".concat(this.getProtocol(), \"' subprotocol\"));\n    this.disconnected = false;\n\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close: function close(event) {\n    logger.log(\"WebSocket onclose event\");\n\n    if (this.disconnected) {\n      return;\n    }\n\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error: function error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\nexport default Connection;","map":null,"metadata":{},"sourceType":"module"}