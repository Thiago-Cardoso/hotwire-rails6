{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport logger from \"./logger\"; // Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nvar now = function now() {\n  return new Date().getTime();\n};\n\nvar secondsSince = function secondsSince(time) {\n  return (now() - time) / 1000;\n};\n\nvar clamp = function clamp(number, min, max) {\n  return Math.max(min, Math.min(max, number));\n};\n\nvar ConnectionMonitor = /*#__PURE__*/function () {\n  function ConnectionMonitor(connection) {\n    _classCallCheck(this, ConnectionMonitor);\n\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n\n  _createClass(ConnectionMonitor, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.isRunning()) {\n        this.startedAt = now();\n        delete this.stoppedAt;\n        this.startPolling();\n        addEventListener(\"visibilitychange\", this.visibilityDidChange);\n        logger.log(\"ConnectionMonitor started. pollInterval = \".concat(this.getPollInterval(), \" ms\"));\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isRunning()) {\n        this.stoppedAt = now();\n        this.stopPolling();\n        removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n        logger.log(\"ConnectionMonitor stopped\");\n      }\n    }\n  }, {\n    key: \"isRunning\",\n    value: function isRunning() {\n      return this.startedAt && !this.stoppedAt;\n    }\n  }, {\n    key: \"recordPing\",\n    value: function recordPing() {\n      this.pingedAt = now();\n    }\n  }, {\n    key: \"recordConnect\",\n    value: function recordConnect() {\n      this.reconnectAttempts = 0;\n      this.recordPing();\n      delete this.disconnectedAt;\n      logger.log(\"ConnectionMonitor recorded connect\");\n    }\n  }, {\n    key: \"recordDisconnect\",\n    value: function recordDisconnect() {\n      this.disconnectedAt = now();\n      logger.log(\"ConnectionMonitor recorded disconnect\");\n    } // Private\n\n  }, {\n    key: \"startPolling\",\n    value: function startPolling() {\n      this.stopPolling();\n      this.poll();\n    }\n  }, {\n    key: \"stopPolling\",\n    value: function stopPolling() {\n      clearTimeout(this.pollTimeout);\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var _this = this;\n\n      this.pollTimeout = setTimeout(function () {\n        _this.reconnectIfStale();\n\n        _this.poll();\n      }, this.getPollInterval());\n    }\n  }, {\n    key: \"getPollInterval\",\n    value: function getPollInterval() {\n      var _this$constructor$pol = this.constructor.pollInterval,\n          min = _this$constructor$pol.min,\n          max = _this$constructor$pol.max,\n          multiplier = _this$constructor$pol.multiplier;\n      var interval = multiplier * Math.log(this.reconnectAttempts + 1);\n      return Math.round(clamp(interval, min, max) * 1000);\n    }\n  }, {\n    key: \"reconnectIfStale\",\n    value: function reconnectIfStale() {\n      if (this.connectionIsStale()) {\n        logger.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \".concat(this.reconnectAttempts, \", pollInterval = \").concat(this.getPollInterval(), \" ms, time disconnected = \").concat(secondsSince(this.disconnectedAt), \" s, stale threshold = \").concat(this.constructor.staleThreshold, \" s\"));\n        this.reconnectAttempts++;\n\n        if (this.disconnectedRecently()) {\n          logger.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n        } else {\n          logger.log(\"ConnectionMonitor reopening\");\n          this.connection.reopen();\n        }\n      }\n    }\n  }, {\n    key: \"connectionIsStale\",\n    value: function connectionIsStale() {\n      return secondsSince(this.pingedAt ? this.pingedAt : this.startedAt) > this.constructor.staleThreshold;\n    }\n  }, {\n    key: \"disconnectedRecently\",\n    value: function disconnectedRecently() {\n      return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n    }\n  }, {\n    key: \"visibilityDidChange\",\n    value: function visibilityDidChange() {\n      var _this2 = this;\n\n      if (document.visibilityState === \"visible\") {\n        setTimeout(function () {\n          if (_this2.connectionIsStale() || !_this2.connection.isOpen()) {\n            logger.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = \".concat(document.visibilityState));\n\n            _this2.connection.reopen();\n          }\n        }, 200);\n      }\n    }\n  }]);\n\n  return ConnectionMonitor;\n}();\n\nConnectionMonitor.pollInterval = {\n  min: 3,\n  max: 30,\n  multiplier: 5\n};\nConnectionMonitor.staleThreshold = 6; // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\n\nexport default ConnectionMonitor;","map":null,"metadata":{},"sourceType":"module"}